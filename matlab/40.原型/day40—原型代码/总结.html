<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        // 工厂模式
        function createFruit(name,color){
            var o = new Object();
            o.name = name;
            o.color = color;
            return o;
        }
        var person1 = createFruit("香蕉","yellow");
        var person2 = createFruit("苹果","red");
        console.log(person1 instanceof createFruit);
        // 解决了创建多个相似对象的问题，创建出来的所有的东西都是object



        // 构造函数模式
        // function Person(name,color){
        //     this.name = name;
        //     this.color = color;
        // }
        // var person1 = new Person("葡萄","purple");
        // console.log(person1 instanceof Person);
        // 解决了工厂模式的问题，不能识别
        // 每次创建实例的时候都要重新创建一次方法
        // 缺点：最大问题在于每次创建实例的时候都要重新创建一次方法(理论上来说每次创建对象的时候对象的属性是不同的，而对象的方法是相同的)，然后呢创建两次完全相同的方法是没有必要的


        // 原型模式
        // function Person(){

        // }
        // Person.prototype.name = "黄建辉";
        // Person.prototype.age = "18";
        // Person.prototype.sex = "男";
        // var person1 = new Person();
        // var person2 = new Person();
        // console.log(person1.name);
        // console.log(person2.name);
        // console.log(person1.age);
        // console.log(person2.age);
        // console.log(person1.sex);
        // console.log(person2.sex);
        // 非常明显的缺点：省略了构造函数传递初始化参数这一环节，结果所有实例在默认情况下都取得了相同的属性值



        // 混合模式（原型模式+构造函数模式）
        // function Person(name,color){
        //     this.name = name;
        //     this.color = color;
        // }
        // Person.prototype.alertInfo = function(){
        //     alert(this.name+this.color);
        // }
        // var person1 = new Person("小新","蓝色");
        // person1.alertInfo();
        // var person2 = new Person("周靖","pink");
        // person2.alertInfo();
    </script>
</body>
</html>